## 引导
在了解``HashMap``之前，我们应该先明白两个概念：``Hash``和``Map``，这可以帮助我们更容易了解``HashMap``的运行原理。

那么何为``Hash``，又何为``Map``呢？

### Hash散列
所谓``Hash``，可以看成是一个函数，我们称之为``散列函数``：
 - **散列函数**：就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值

简单来说，``Hash``函数可以将一个范围的数字映射到另一个范围之中，这种需求在很多场景都非常有用，如``分库分表``，``负载均衡``等等，可以将之抽象为一句话：``给输入的值分组``，当然，看完这篇文章你就会明白这句话所表达的真正的含义！

在我们日常使用中，我们的``Hash``散列更多的应用于处理对象的分组之中，但是``Hash``的入参大多都是面向数字的，那么我们该如何对对象进行散射呢？这里就要引入一个新的概念：``HashCode``。

有Java基础的同学都知道，在Java中，Object对象是每一个普通对象的父类，这就导致每个对象都有一个``hashCode()``方法，而部分对象对该方法进行了重写。我们可以通过该方法获取到当前对象的``哈希码``,简称``hashCode``：
 - **哈希码(hashCode)**：哈希码并不是完全唯一的，它是一种算法，让同一个类的对象按照自己不同的特征尽量的有不同的哈希码，但不表示不同的对象哈希码完全不同。也有相同的情况，看程序员如何写哈希码的算法。

``hashCode``本身的出现就是为了提高哈希表的性能，当然我们也可以写一个自己的哈希算法去计算一个对象的hash值，对于概念上来讲，我们只需要明白可以通过一个java对象的``hashCode``使用``Hash``函数，获取到该对象所属的分组即可，而一个最简单的``Hash``函数实现就是``hashCode``对于目标范围最大值做``Mod``运算：
```
int hash(int hashcode, int maxlen){
  return hashcode & maxlen;
}
```

当然在实际中，我们可能会对hashcode做一些额外的移位，逻辑运算等操作使之分布更加均匀。
### Map
Map是一种``K-V``形式的数据结构，一个唯一的key，会唯一对应一个value。也就是说，在Map容器里不允许两个一模一样的key。

一个简单的Map结构如下：
```
{
  "key1":"value1",
  "key2":"value2",
  "key3":"value3"
}
```
对于这种数据结构，并且Map会对外提供一些方法来实现对内部数据的操作：
```
V put(K key, V value)
V get(Object key)
V remove(Object key)
boolean containsKey(Object key)
```
可见Map对于我们操作``K-V``形式的数据非常方便，实现的方式有很多，最简单粗暴的实现方式是使用``List``来存储每一个``K-V``组对，对于每种方法的实现只需要暴力循环碰撞即可，对于少量数据这种做法未必不可，如果数据量庞大之千万，我们就要换一种更加高效，速度更快的实现方式：``HashMap``。
